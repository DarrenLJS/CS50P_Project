# Quarter Sword Demo: Spoilance

## Video Demo:  https://youtu.be/SyHb9xHgqmU

## Description:

Taking inspiration from Half Sword game, Quarter Sword features a medieval arena turn-based combat game, except with very limited features (I tried my best as a novice python programmer). You spawn as a hero (name him however you like) in the middle of a 5x5 arena, together with 3 other enemy AI bots spawned in random locations. Your goal is to eliminate all enemies, or die trying. In the arena, there are also items spawned in random locations to aid you (and your enemies) in battle: a sword to increase your attack, armour to decrease your enemies' attacks, and apples to heal. During each turn, you can only choose 1 of 2 actions: move or attack. You can move 1 tile North (n), South (s), East (e), or West (w). Similarly, you can attack enemies in range in this manner. Moving into a tile with an item automatically picks it up, unless certain conditions are met (e.g. you already have a sword or armour equipped/your HP is at its maximum). When attacking enemies, an attack roll mechanic is triggered, where both the attacker and defender roll 3 die each, and the score is the sum of the results of the 3 die. If the attacker's score is higher than or equal to the defender's, the attacker will successfully damage the defender. However, if the defender's score is higher than the attacker's, the defender will successfully block the attack and suffer no damage. To eliminate your enemies, deplete their health to 0, but if your health reaches 0, it is game over!

Project consists of 3 Python files: project, test_project, and game. game.py contains classes: Character, Item, Player, Enemy, Apple, Armour, and Sword. project.py contains main function, as well as 4 other custom functions: generate_map, generate_players, enemy_turn, and update_players. test_project.py tests if the custom functions in project.py work as intended.

### game.py

Parent class Character is initialised with a str name, and x and y values as the starting location. Character has 7 attributes: name, location, health, offense, weapon, armour, and equipment. self.name is for printing f strings. self.location stores the current location of the Character on the map in [x, y] format. self.health has max health of 100. self.offense determines the damage done when Character attacks another Character. self.weapon defaults to "fists", but changes to Sword.name when equipped. self.armour determines the reduction in damage received by Character when Character is attacked successfully. self.equipment stores the item objects picked up by Character.

Parent class Character has 2 behaviors: move and attack. self.move takes in a str direction, which should be one of "n"/"s"/"e"/"w", and items_d and players_d as game statuses. Within self.move, valid_direction_checker function is defined to help determine if the str direction input is valid. Invalid str direction inputs include: Not one of "n"/"s"/"e"/"w", moving out of bounds of map, and moving into a location occupied by another Character. If invalid, raise ValueError. Else, proceed to move Character to specified location and print a f string. move also considers if location contains an item, and if so, check if it is Apple subclass, or Sword/Armour subclass. If Apple, if self.health is less than 100, consume Apple, heal self.health by 25 and remove Apple object from items_d to update game state. Else, do not consume apple. If Sword/Armour, if unequipped, Character picks up Sword/Armour, boost relevant attributes, add item to inventory, and remove Sword/Armour object from items_d to update game state. Else, do not pick up Sword/Armour. When item is picked up/consumed, print a f string. self.attack takes in a str player_name and players_d. The str player_name input refers to the target the Character wants to attack. Invalid target inputs include: Not in players_d which is a dict of remaining Characters in the game, and target not in range of Character (similar to self.move). Else, perform attack_roll function, which picks a random int from 3 to 18 for both attacker and defender. If attacker's score >= defender's score, decrease defender's health by (self.offense - defender.armour) and print a f string. If defender's score > attacker's score, print another f string that states the defender successfully blocked the attack.

Parent class Item is initialised with a str name, and x and y values as the starting location, which are stored in name and location attributes respectively (similar to Character class).

Subclasses Player and Enemy inherit the attributes and behaviors of parent class Character, while subclasses Apple, Armour, and Sword inherit the attributes of parent class Item. Apple has an additional attribute called healing = 25, Armour has an additional attribute called armour = 5, and Sword has an additional attribute called offense = 30.

### project.py

import all classes from game.py, and sys

generate_map function takes in 3 int arguments: armours, swords, and apples, and returns a dict called items_d. key:value pairs in items_d represent item object:location of item on map. generate_map function generates number of armours, swords, and apples specified by the arguments in random locations on 5x5 map. In addition to taking into account Player starting location [2, 2], items cannot be spawned in the same location.

generate_players function takes in 3 arguments: int number of enemies, str hero name, and dict items_d, and returns a dict called players_d. key:value pairs in players_d represent Character.name:Character objects. generate_players function spawns hero and number of enemies specified by argument in random locations on 5x5 map. items_d is needed to get locations of spawned items. Similar to generate_map, enemies cannot be spawned in the same location as the hero, items, or one another.

enemy_turn function simulates AI bot behavior of the enemies. enemy_turn function takes in 3 arguments: str enemy name, dict players_d, and dict items_d, and returns the action of the bot, which is either enemy.move or enemy.attack. Within enemy_turn, pick_action function is defined to help determine the bot's action, which takes in no argument. Firstly, pick_action function searches for nearby Characters, and if there are nearby Characters, returns ["attack", [args*]] where args refer to str Character names. Secondly, pick_action function searches for nearby Items, and if there are nearby Items, returns ["move", {args*}] where args refer to item object:location pairs. Else, pick_action returns ["move"]. Therefore, the bot prioritises attacking > moving to items > moving randomly. If action = ["attack", [args*]], enemy_turn randomly selects within [args*] for a target and returns enemy.attack(target, players_d). If action = ["move", {args*}], if enemy.health < 100 and if there are Apples nearby, filter {args*} for Apples, randomly select one Apple to move to, and return enemy.move(direction, items_d, players_d). If action = ["move", {args*}], if enemy.health = 100 or no Apple nearby, filter {args*} for Armours/Swords if not yet picked up, randomly select one Armour/Sword to move to, and return enemy.move(direction, items_d, players_d). If action = ["move"], randomly select a direction "n"/"s"/"e"/"w" and return enemy.move(direction, items_d, players_d).

update_players function filters and updates dict players_d with remaining Characters with health > 0, eliminating those with health <= 0 from the game.

Therefore, main function dictates flow of game. To start, prompt user for str custom name for hero. By default, items_d = generate_map(4, 4, 4) and players_d = generate_players(3, hero name, items_d). Once game begins, start while loop. Firstly, print {Item name:location}, {Character name:location}, and every Character's health and equipment before every turn. Secondly, prompt user for an action: "move", "attack", or "surrender". If invalid action, reprompt. If "surrender", sys.exit(). If "move", prompt user for a direction to call self.move(direction, items_d, players_d). If "attack", prompt user for a target to call self.attack(target, players_d). If invalid direction/target, reprompt user for an action again. After hero's turn, update_players(players_d) and check if only hero remains, and if so, victory! Else, run enemy_turn function for remaining enemies in players_d. Lastly, update_players(players_d) and check if hero is not inside players_d, and if so, game over! Game continues by looping through hero's and enemies' turns until either "victory!" or "game over!" condition is met.

### test_project.py

import all classes from game.py
import generate_map, generate_players, enemy_turn, update_players from project.py
import pytest

test_generate_map function tests if generate_map(4, 4, 4) works as intended, by checking for correct numbers of Armours, Swords, and Apples, and no duplicate locations in items_d (no 2 items can spawn in the same location).

test_generate_players function tests if generate_players(3, "hero", items_d) works as intended. 4 checks: "hero" location is in [2, 2], number of enemies = 3, no duplicate locations of Characters in items_d (Characters cannot spawn in the same locations as Items), and no duplicate Character locations (no 2 Characters can spawn in the same location).

test_update_players function simulates 2 enemies with health = 0 in players_d, which contains hero and 3 enemies. It checks if update_players function correctly removes the 2 enemies, and not the rest.

test_enemy_turn function runs 2 simulations. In simulation 1, enemy_1 is spawned with < 100 health and Armour next to an Apple, enemy_2 is spawned next to hero and a Sword, enemy_3 is spawned at the corner of map [4, 4], and enemy_4 is spawned with a Sword at the corner of map [4, 0] next to another Sword. After enemy_turn, check that enemy_1 moves to Apple, consumes it and heals; enemy_2 attacks hero instead of moving to Sword and stays put; enemy_3 randomly moves to either [3, 4] or [4, 3] and does not move out of bounds; and enemy_4 randomly moves to either [3, 0] or [4, 1] since enemy_4 already equipped with Sword. In simulation 2, enemy_1 is next to an Armour and a Sword, enemy_2 will be next to enemy_1 and hero, and enemy_3 is next to an Armour. After enemy_turn, check that enemy_1 moves to Sword and picks it up instead of moving to Armour as already equipped; enemy_2 randomly attacks either enemy_1 or hero and stays put; and enemy_3 moves to Armour and picks it up. Lastly, check that items_d is updated to have 2 items remaining on the map.

